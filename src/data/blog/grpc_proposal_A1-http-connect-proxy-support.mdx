---
title: "(gRPC Proposal) - A1. Behind the Proxy Curtain"
author: eunsang
pubDatetime: 2025-08-16T01:00:00Z
modDatetime: 2025-08-16T01:00:00Z
slug: grpc-proposal-a1-behind-the-proxy-curtain
featured: false
draft: false
tags: [grpc, proposal]
description: ""
---

I’ve always been fascinated by how cloud systems talk to each other, yet networking layers and RPC frameworks often felt like hidden machinery. Among them, gRPC stood out to me — powerful, widely adopted, but sometimes a black box. To unpack that mystery, I’m starting the **“gRPC Proposal Series”**: a collection of posts where I study, dissect, and experiment with gRPC proposals, both to deepen my understanding and to share insights with others navigating distributed systems.

gRPC is a high-performance, open-source RPC framework backed by Google, designed for efficient, language-agnostic communication. The team behind it documents key design choices through [proposals on GitHub](https://github.com/grpc/proposal), which serve as the blueprint for new features and enhancements.

With that in mind, let’s dive into the first proposal in the series: [HTTP CONNECT Proxy Support](https://github.com/grpc/proposal/blob/master/A1-http-connect-proxy-support.md).

import NotesPanel from '../../components/NotesPanel.astro';

export const notes = {
  background: `
    <div>
      <h3>Background</h3>
      <p>Have you ever tried running gRPC through a corporate proxy and felt like the network was working against you? That’s because most TCP proxies don’t understand gRPC, which can break client-side load balancing. The solution? HTTP CONNECT — a way for proxies to create a tunnel straight to the backend. This keeps your client smart and load-balanced, while still letting the proxy do its thing.</p>
    </div>
  `,
  implementation: `
    <div>
      <h3>Implementation</h3>
      <p>At the heart of this is the handshaker in C-core — it’s the bouncer managing who gets in. Then there’s the proxy mapper hook, the real star here: it lets you rewrite addresses right before the connection. Java leans on <code>java.net.ProxySelector</code>, Go uses a custom dialer, and C-core does its thing like a pro. The goal? Make every language catch up without breaking the flow.</p>
    </div>
  `,
  proposed_functionality: `
    <div>
      <h3>Proposed Functionality</h3>
      <p>Think of the proxy mapper as a choose-your-own-adventure for connections. First, you get a hook before name resolution — useful if you want to change the server name. Then there’s a hook before connecting, which lets you swap the target address. Together, they give the client the final say: when to use a proxy and when to go direct.</p>
    </div>
  `,
  use_cases: `
    <div>
      <h3>Use Cases</h3>
      <p>Corporate life is one scenario: everything must go through a proxy. Internal traffic might bypass it, but usually, it’s a one-size-fits-all. </p>
      <p>Partial protection is another: only certain addresses go through a proxy. Custom logic decides the fate of each request.</p>
      <p>Finally, some services need to hide their inner workings. Public-facing but internally guarded, these services rely on the proxy for access — the only route to keep internal architecture safe.</p>
    </div>
  `,
  case_1: `
    <div>
      <h3>Case 1: Full Corporate Proxy</h3>
      <p>Everything goes through the proxy. The proxy mapper redirects to the proxy instead of the backend. Drawback? gRPC loses per-call load balancing because the client can’t see backend addresses. Simple but limited.</p>
    </div>
  `,
  case_2: `
    <div>
      <h3>Case 2: Selective Proxying</h3>
      <p>Only some connections go through the proxy. The proxy mapper swaps the target address when needed, but the client still resolves backend addresses and can do load balancing. Smart and flexible.</p>
    </div>
  `,
  case_3: `
    <div>
      <h3>Case 3: Hybrid Approach</h3>
      <p>This is the high-wire act. The resolver returns proxy addresses with load-balancer flags, and the mapper rewrites them as needed. Original internal addresses are preserved in HTTP CONNECT requests. Works only with <code>grpclb</code> and requires careful management of proxy lists — but it’s powerful.</p>
    </div>
  `,
  rationale: `
    <div>
      <h3>Rationale</h3>
      <p>Why this design? Flexibility. By offering hooks at two points, we cover all three cases. Case 3 is tricky: you need synchronized proxy lists. A gRPC-level proxy is possible, but introduces security concerns. This proposal balances flexibility, performance, and safety.</p>
    </div>
  `
};

<NotesPanel notes={notes}>

HTTP CONNECT Proxy Support
--------------------------
* Author(s): Mark D. Roth (roth@google.com), Eric Anderson (ejona@google.com)
* Approver: a11r
* Status: Implemented
* Implemented in: C-core (Java and Go are in progress)
* Last updated: 2017-03-20
* Discussion at: https://groups.google.com/d/topic/grpc-io/zG7iYpDw6lk/discussion

<section id="abstract">
## Abstract

Describes what types of TCP-level proxy setups gRPC will support and
how those setups interact with client-side per-call load balancing
policies (e.g., `grpclb` or `round_robin`).
</section>

<section id="background">
## Background

It may be useful to read the following docs before this one:

- [gRPC load balancing](https://github.com/grpc/grpc/blob/master/doc/load-balancing.md)
- [gRPC name resolution](https://github.com/grpc/grpc/blob/master/doc/naming.md)
- [gRPC service config](https://github.com/grpc/grpc/blob/master/doc/service_config.md)

A TCP-level proxy is one that does not know anything about gRPC.
It accepts a TCP connection from a client, creates a new TCP connection
to another server, and forwards all bytes from the client to the server,
without actually understanding anything about the contents of those bytes.

Note that client-side per-call load-balancing within gRPC requires the
client to establish connections to individual backends.  Because of this,
use of a TCP-level proxy may limit the ability to do client-side per-call
load balancing in some environments.

</section>

<section id="related-proposals">
### Related Proposals

- [gRFC A2: Service Configs in DNS](https://github.com/grpc/proposal/pull/5)
- [gRFC A5: Encoding grpclb data in DNS](https://github.com/grpc/proposal/pull/10)
</section>

<section id="proposal">
## Proposal
</section>

gRPC will support TCP-level proxies via the HTTP CONNECT request,
defined in [RFC-2817](https://tools.ietf.org/html/rfc2817).

<section id="use-cases">
### Use Cases

We are aware of the following use-cases for TCP-level proxying with gRPC:

1. A corp environment where all outbound traffic must go through a proxy.
   This environment has the following properties:
    - Name resolution is done by the proxy, either because external DNS
      is not resolvable internally, or because the proxy requires the
      CONNECT request to use a hostname instead of an IP address.
    - Internal traffic does not need to use the proxy, but external traffic
      does.
    - In some environments, there will not be any gRPC traffic to any internal
      servers, in which case we can unconditionally send *all* connections
      through the proxy.  This configuration is generally triggered by
      some centralized signal, such as the `http_proxy` environment variable
      or Java system properties.

2. A partially protected environment, where access to certain addresses
   must go through a proxy.  This environment has the following
   properties:
    - Name resolution of protected servers works normally, and the proxy
      allows the CONNECT request to use an IP address instead of a hostname.
    - Only requests for certain hosts must go through the proxy.
      Requests to other servers work without the proxy.
    - Custom logic is used to determine which hosts the proxy will be
      used for.

3. An environment where a service is accessible from the Internet but
   its internal architecture should not be exposed publicly.  This
   environment has the following properties:
    - Name resolution of internal names does not work externally (i.e.,
      all internal resolution must be done via the proxy).
    - Only requests for services behind the proxy will go through it.
</section>

<section id="proposed-functionality">
### Proposed Functionality

We propose the following functionality to support these use cases:

- We will have some internal state (e.g., a channel arg in C-core) that
  both triggers the use of the HTTP CONNECT handshaker and specifies the
  argument to be used in the CONNECT request.

- We will support a new type of hook called a *proxy mapper*, which
  offers two points at which proxies can be selected:
    - Right before the server name is resolved, the proxy mapper can be used
      to programmatically override the name that will be resolved.  It
      will also be able to set the internal state to trigger use of the
      HTTP CONNECT handshaker.
    - Right before we connect to the target address, the proxy mapper can
      be used to programmatically override the address that we will
      connect to.  It will also be able to set the internal state to trigger
      use of the HTTP CONNECT handshaker.
</section>

<section id="addressing-use-cases">
### Addressing Use Cases

This new functionality will be used to address the three use-cases
described above, as follows.
</section>

<section id="case-1">
#### Case 1

Case 1 will be addressed using the proxy mapper hook for overriding the
server name to resolve.  Sites that may want to send only external servers
through the proxy can implement their own proxy mapper to do this.
We will provide a default proxy mapper implementation that looks for the
existence of the `http_proxy` environment variable (or equavalent
signal).  If that signal is present, it will do the following:
- Ask the resolver to resolve the proxy name instead of the server name
  requested via the client API.  (Note that this will cause us to
  create a single subchannel to the proxy, as opposed to one
  subchannel for each backend server.)
- Add the state described above triggering the use of the HTTP CONNECT
  handshaker, with the argument set to the server name requested via
  the client API.

Note that in this case, because the client cannot know the set of server
addresses, it is impossible to use the normal gRPC client-side per-call
load balancing.  It *is* possible to do load balancing on a per-connection
basis, but that may not spread out the load evenly if different clients
impose a different amount of load.  (Note that even if we established
multiple connections to the proxy, we would have no guarantee that each
connection would go to a different backend server.)

Also, note that in this case, because the client is not resolving the
server name itself, it will not have access to the service config.
</section>

<section id="case-2">
#### Case 2

This case will be addressed using the proxy mapper hook for overriding the
address to connect to.  When the proxy mapper sees an address that
should go through the proxy, it will do the following:
- Set the target address to the proxy address.
- Add the additional state described above to trigger the use of the
  HTTP CONNECT handshaker, with the argument set to the original
  target address.  Note that in this case, the server name used in
  the HTTP CONNECT request will be an IP address and port, not a
  hostname (i.e., we are not relying on the proxy to do name
  resolution for us).

In contrast to case 1, in case 2, it *is* possible to do the normal
gRPC client-side per-call load balancing, because the client does know
the set of server addresses.  The fact that the connections to those
individual addresses go through a TCP-level proxy does not interfere
with the client opening a separate subchannel to each address.

In this case, because the client is resolving the server name itself,
the client will have access to the service config as usual.
</section>

<section id="case-3">
#### Case 3

This case is similar to case 1 in that the resolver cannot return
the actual addresses of the servers.  However, we (ab)use the gRPC
load-balancing design to work around this, so that it looks more like
case 2.

In this case, the resolver must return the address of the proxy, but
with the `is_balancer` bit set.  This can be done either by writing a
custom resolver or by publishing a DNS SRV record for the server name's
`grpclb` service that points to the proxy name (as per [gRFC A5: Encoding
grpclb data in DNS](https://github.com/grpc/proposal/pull/10)).

Next, we use the proxy mapper hook for overriding the address to
connect to.  The proxy mapper implementation will have to detect two
types of addresses:
- When it sees the proxy address, it will set the HTTP CONNECT argument to
  the original server name (which will cause the proxy to establish a
  connection to one of the load balancers).
- When it sees any internal address (i.e., the addresses returned by
  the load balancer), it will replace it with the proxy address and set
  the HTTP CONNECT argument to the internal address.

Note that this will work only if the `grpclb` load balancing policy is
in use; it will not work with client-side policies like `round_robin`.

Also, note that if a custom resolver is implemented, then the client
may not have access to the service config.  However, if the DNS SRV
record is published, then the service config will be returned normally.
</section>

<section id="rationale">
## Rationale

The proposed design allows two different ways of triggering use of
the HTTP CONNECT handshaker code, which addresses the needs of the
use-cases described above.

There is one down-side to the approach for case 3, which is that the proxy
mapper and the name resolver both have to agree on the list of known
proxy addresses.  So, for example, if the proxy mapper implementation
is getting the list of proxy addresses from a local file, the service
owner would need to first push an updated list that contains the new
proxy address to all clients.  Then, once all clients have been updated,
the new proxy can be added to DNS.

Note that another alternative for case 3 would be to use a gRPC-level
proxy instead of a TCP-level proxy, where the proxy natively speaks gRPC.
The idea is that the proxy accepts a gRPC request from the external client
and then uses its own client on the internal side, which does the name
resolution and per-call load balancing internally to the backend servers.
The trade-off here is that this approach requires that the gRPC-level
proxy be trusted by all internal servers, which has security implications
(e.g., a successful attack on the proxy would yield priviledged access
on all internal servers).
</section>

<section id="implementation">
## Implementation

In C-core, the HTTP CONNECT handshaker was already implemented.
The following additional changes have also been made:

- [grpc/grpc#9383](https://github.com/grpc/grpc/pull/9383) (changes
  HTTP CONNECT handshaker to be triggered via channel args)
- [grpc/grpc#9372](https://github.com/grpc/grpc/pull/9372) (adds proxy
  mapper hook for address rewriting)
- [grpc/grpc#9557](https://github.com/grpc/grpc/pull/9557) (adds proxy
  mapper hook for name rewriting)

In Go, this functionality is being provided via a custom dialer:

- [grpc/grpc-go#1098](https://github.com/grpc/grpc-go/pull/1098)

In Java for case 1, Java's `java.net.ProxySelector` is observed and usable
starting in v1.11.0. `ProxySelector` is generally configured with the Java
properties `-Dhttps.proxyHost` and related. grpc-java supports HTTP Basic Proxy
Authentication and credentials can be specified via the default
`java.net.Authenticator`. The experimental `GRPC_PROXY_EXP=host:port`
environment variable enabled limited proxy support starting in v1.0.3.
</section>

<section id="open-issues-if-applicable">
## Open issues (if applicable)

N/A

</section>

</NotesPanel>