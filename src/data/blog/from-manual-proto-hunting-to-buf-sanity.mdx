---
title: From Manual Proto Hunting to Buf Sanity 
author: eunsang
pubDatetime: 2025-07-29T01:00:00Z
modDatetime: 2025-07-29T01:00:00Z
slug: from-manual-proto-hunting-to-buf-sanity
featured: false
draft: false
tags: [grpc, protobuf, python, buf, uv, envoy, xds]
description: ""
---
> This post was heavily helped by [“Protobuf dependency management with Buf”](https://www.youtube.com/watch?v=OSdQlnoO0og), so big thanks to Mike for hosting the tutorial. 

### Why `buf` and `uv` in 2025 Python Dev?

In the scorching hot midsummer of 2025, there was me — trying to write an xDS server in Python to dynamically configure network policy for a web app with an Envoy sidecar, all running in Docker. I didn’t know much about Protocol Buffers (honestly, I still barely do), all I had was ChatGPT telling me: *“You should collect the proto schemas that Envoy uses for its services.”* So I grabbed things like:

* envoy/service/discovery/v3/ads.proto
* envoy/config/listener/v3/listener.proto
* envoy/config/route/v3/route.proto
* ... 

I had no idea how hard it would be to generate Python code from these. Turns out, each of these proto files turned out to have their own imports — like `buf/validate/validate.proto`, which depended on yet another, like `google/protobuf/descriptor.proto`. The web of dependencies kept growing, and it quickly became clear how tangled things could get.

So I did the only thing I could think of: I followed the imports manually, repo by repo. I downloaded the necessary folders from GitHub — pulling from Google's protos, UDPA, xDS, protoc-gen-validate, and Envoy itself. Eventually, I got everything to compile. And when the Python files finally generated successfully, I was honestly kind of amazed.

But then I thought: No way. It can’t be like this forever.

I searched for a better way to manage proto dependencies and stumbled upon a YouTube tutorial titled [“Protobuf dependency management with Buf”](https://www.youtube.com/watch?v=OSdQlnoO0og). That’s when I discovered `buf`.

What follows is my humble implementation — and a few lessons learned — as I moved beyond just compiling protos into actually writing a working gRPC server and client in Python. 

Got it — here’s a rewritten version of that section with all code blocks replaced by natural descriptions and links to your GitHub repo (you can fill in the real URLs where needed). It keeps the flow conversational and lightweight, just like the rest of your blog.


### Lead into a Simple gRPC Service

So with protobuf, development kinda starts upside down — or head-first, maybe. You don’t write Python code first; instead, you start by defining your APIs in a `.proto` file. There, you describe a `service` — kind of like function signatures if you're from the Java world — along with the `message` types (UDTs) that your API takes and returns.

In my case, I was following the tutorial, and I had a proto file called `pokedex.proto` ([`proto/pokeapi/v1/pokedex.proto`](https://github.com/yourusername/pokedex-grpc/blob/main/proto/pokeapi/v1/pokedex.proto)). 

At the bottom of that file, there’s a message type that pulls in a reference to another proto — `pokemon/v1/types.proto`. That one lives out in the wild on the Buf Registry: [pixelperfect/gametypes](https://buf.build/pixelperfect/gametypes/docs/main:pokemon.v1)

So right there, we’re dealing with a remote dependency. But unlike the chaos I experienced before, this time I used `buf` to manage everything. No more manually downloading and copy-pasting folders from GitHub repos. Just clean, versioned module imports.

To set things up, I created a new Python project using [`uv`](https://github.com/astral-sh/uv). The basic idea was:

1. Initialize a project (mine was called `pokedex-grpc`)
2. Create a `proto/` directory and initialize `buf` inside it
3. Add a `buf.yaml` with dependency config
4. Run `buf lint` to check things
5. Run `buf mod update` to lock dependencies

After that, I added a `buf.gen.yaml`([`proto/buf.gen.yaml`](https://github.com/yourusername/pokedex-grpc/blob/main/proto/buf.gen.yaml)
) to tell `buf` how to generate Python code from the protos. This includes both the regular protobuf classes and the gRPC-specific server/client interfaces.

Once you run the generator, everything ends up in a `/gen` folder — `.py` and `.pyi` files neatly laid out and ready to import from your Python app. No hassle.

### The gRPC Server and Client: Catching Pikachu

Once the Python files were generated using `buf`, it was time to actually *run* something.

The idea was simple:

* Spin up a gRPC server that responds to `GetPokemon` requests
* Write a lightweight client that queries for a Pokémon 
* Make sure the stub-based response comes back with all the bells and whistles — name, type, abilities, moves, stats

I didn’t want to overcomplicate things, so I hardcoded a sample Pikachu response right in the server code.

#### Server-side

The server ([`grpc_server.py`](https://github.com/yourusername/pokedex-grpc/blob/main/grpc_server.py)) implements the `PokedexService` from our `pokedex.proto`. It receives a Pokémon name (like `"Pikachu"`) and responds with a `Pokemon` message — populated using types from the external schema we pulled in earlier (`pixelperfect/gametypes`).

#### Client-side

The client ([`grpc_client.py`](https://github.com/yourusername/pokedex-grpc/blob/main/grpc_client.py)) connects to `localhost:50051`, sends a `GetPokemonRequest`, and prints the response from the server. It uses the generated stub class `PokedexServiceStub` to handle the request/response logic.

To try it yourself, make sure Python can find the generated gRPC modules — those live under `proto/gen`, so you’ll want to set your `PYTHONPATH` to that directory before running anything.

Then, start the server in one terminal and the client in another using `uv run grpc_server.py` and `uv run grpc_client.py`.

The client should return the full Pokémon object — type, abilities, moves, and base stats — unmarshalled and printed nicely, thanks to Python’s protobuf bindings.

### `uv`: The Ultimate Python Project Tool (at least so far, I think)

I always hated Python virtual environments or Conda when it comes to Python package management. As a dev with (shallow) experience in npm, Gradle, or even Maven, it felt so chunky whenever I tried to set up a Python project. But then I came across `uv`.

`uv` changed the game for me. Instead of wrestling with confusing virtualenvs, fragmented package installs, and managing multiple config files, `uv` bundles all that pain into one simple, fast, and reliable tool.

There are experts who know far better than me about `uv`, but simply put: uv uses Rust to deliver fast, reliable Python environment and dependency management with deterministic locking that prevents version conflicts and ensures repeatable installs.

### Conclusion

Using protobuf with `buf` for dependency management and Python with `uv` for environment and package handling has truly enhanced my development experience—something I really didn’t expect in the Python world. I try to be an unopinionated coder without prejudices, but honestly, I hadn’t really loved Python development until now.

This combination brought me where I wanted to go with much more ease: protobuf’s concise, portable API specifications together with buf’s clean and reliable dependency management, paired with uv’s seamless, reliable packaging and environment management, make Python development smoother and more enjoyable than ever. 
