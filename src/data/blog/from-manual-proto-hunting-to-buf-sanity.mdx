---
title: From Manual Proto Hunting to Buf Sanity 
author: eunsang
pubDatetime: 2025-07-29T01:00:00Z
modDatetime: 2025-07-29T01:00:00Z
slug: from-manual-proto-hunting-to-buf-sanity
featured: false
draft: false
tags: [grpc, protobuf, python, buf, uv, envoy, xds]
description: ""
---
> This post was heavily helped by [‚ÄúProtobuf dependency management with Buf‚Äù](https://www.youtube.com/watch?v=OSdQlnoO0og), so big thanks to Mike for hosting the tutorial. 

### Why `buf` and `uv` in 2025 Python Dev?

In the scorching hot midsummer of 2025, there was me ‚Äî trying to write an xDS server in Python to dynamically configure network policy for a web app with an Envoy sidecar, all running in Docker. I didn‚Äôt know much about Protocol Buffers (honestly, I still barely do), all I had was ChatGPT telling me: *‚ÄúYou should collect the proto schemas that Envoy uses for its services.‚Äù* So I grabbed things like:

* envoy/service/discovery/v3/ads.proto
* envoy/config/listener/v3/listener.proto
* envoy/config/route/v3/route.proto
* ... 

I had no idea how hard it would be to generate Python code from these. Turns out, each of these proto files turned out to have their own imports ‚Äî like `buf/validate/validate.proto`, which depended on yet another, like `google/protobuf/descriptor.proto`. The web of dependencies kept growing, and it quickly became clear how tangled things could get.

So I did the only thing I could think of: I followed the imports manually, repo by repo. I downloaded the necessary folders from GitHub ‚Äî pulling from Google's protos, UDPA, xDS, protoc-gen-validate, and Envoy itself. Eventually, I got everything to compile. And when the Python files finally generated successfully, I was honestly kind of amazed.

But then I thought: No way. It can‚Äôt be like this forever.

I searched for a better way to manage proto dependencies and stumbled upon a YouTube tutorial titled [‚ÄúProtobuf dependency management with Buf‚Äù](https://www.youtube.com/watch?v=OSdQlnoO0og). That‚Äôs when I discovered `buf`.

What follows is my humble implementation ‚Äî and a few lessons learned ‚Äî as I moved beyond just compiling protos into actually writing a working gRPC server and client in Python. 

### Lead into a Simple gRPC Service

So with protobuf, development kinda starts upside down ‚Äî or head-first, maybe. You begin not with Python code, but by writing APIs in a `.proto` file. There, you define the `service` ‚Äî which sort of looks like function signatures if you're coming from Java ‚Äî and then the `message` types, which are like UDTs (user-defined types) that your APIs accept and return.

In our case, we had a ready-made proto file from the tutorial called `pokedex.proto`, which looks like this:

```proto
syntax = "proto3";
package pokeapi.v1;
import "pokemon/v1/types.proto";

service PokedexService {
  rpc GetPokemon(GetPokemonRequest) returns (GetPokemonResponse);
}
message GetPokemonRequest {
  string name = 1;
}
message GetPokemonResponse {
  Pokemon pokemon = 1;
}
message Pokemon {
  pokemon.v1.Pokemon pokemon = 1;
}
```

See that last message ‚Äî `Pokemon`? It uses another `Pokemon` type from an external proto file: `pokemon/v1/types.proto`. That file isn‚Äôt ours ‚Äî it lives out there on the Buf Registry at [buf.build/pixelperfect/gametypes](https://buf.build/pixelperfect/gametypes/docs/main:pokemon.v1). That‚Äôs where dependency management comes in, and this time we‚Äôre not doing it manually. We‚Äôre using `buf`, a tool made to clean up that whole messy proto-import scene.

Now, I‚Äôm not doing anything fancy here. Just a simple use of the `buf` CLI to create a Python gRPC app that can query for a Pok√©mon by name using a generated stub. So I‚Äôll keep the steps minimal.

First, initialize a Python project with `uv` (don‚Äôt worry, I‚Äôll explain *why* `uv` later). You can do that like this:

```bash
uv init pokedex-grpc
```

Then, run:

```bash
mkdir proto && cd proto 
buf config init
```

This will generate a clean `buf.yaml` file where you define which external proto schemas you want to import into your proto files. It might look like this:

```yaml
# For details on buf.yaml configuration, visit https://buf.build/docs/configuration/v2/buf-yaml
version: v2
deps:
  - buf.build/pixelperfect/gametypes  # üëà this pulls in the external schema you need
lint:
  use:
    - STANDARD
breaking:
  use:
    - FILE
```

After that, run:

```bash
buf lint
```

to make sure everything's sane, and then:

```bash
buf mod update
```

This creates a `buf.lock` file that pins the exact versions (technically: content digests) of the remote proto modules listed in your `deps`. It also downloads them to your local machine ‚Äî somewhere like `~/.cache/buf` on Linux/macOS or `%USERPROFILE%\AppData\Local\buf\cache` on Windows.

Next, let‚Äôs tell `buf` how to generate Python code from our `pokedex.proto`. We do that with a `buf.gen.yaml` file that looks like this:

```yaml
version: v2
plugins:
  - remote: buf.build/protocolbuffers/python
    out: ./gen
    include_imports: true
  - remote: buf.build/protocolbuffers/pyi
    out: ./gen
    include_imports: true
  - remote: buf.build/grpc/python:v1.74.0
    out: ./gen
    include_imports: true
```

This will generate `.py` and `.pyi` files under the `gen/` directory ‚Äî both the message classes and the gRPC client/server interfaces.
