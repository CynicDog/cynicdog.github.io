---
import type { ImageMetadata } from 'astro';

interface Props {
  src: ImageMetadata | string;
  alt: string;
  caption?: string;
}

const { src, alt, caption } = Astro.props;

const svgUrl = typeof src === 'string' ? src : src.src;
---

<figure class="w-full max-w-full overflow-hidden my-8">
  <div class="excalidraw-svg w-full max-w-full overflow-hidden" data-svg-url={svgUrl} aria-label={alt}>
    <img src={svgUrl} alt={alt} style="display: none;" />
  </div>
  {caption && <figcaption class="text-center mt-4 text-sm text-skin-base italic">{caption}</figcaption>}
</figure>

<script is:inline>
  function modifySvg(svgString) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, 'image/svg+xml');
    const svg = doc.documentElement;

    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.classList.add('w-full', 'h-auto');

    doc.querySelectorAll('text').forEach((text) => {
      text.removeAttribute('fill');
      text.classList.add('fill-skin-base');
    });

    doc.querySelectorAll('rect').forEach((rect) => {
      rect.removeAttribute('fill');
      rect.classList.add('fill-skin-soft');
    });

    doc.querySelectorAll('path').forEach((path) => {
      path.removeAttribute('stroke');
      path.classList.add('stroke-skin-accent');
    });

    doc.querySelectorAll('g').forEach((g) => {
      g.classList.add('excalidraw-element');
    });

    return new XMLSerializer().serializeToString(doc);
  }

  async function loadAndInjectSvg(container) {
    const svgUrl = container.dataset.svgUrl;
    if (!svgUrl) return;

    try {
      const response = await fetch(svgUrl);
      if (!response.ok) throw new Error(`Failed to fetch SVG: ${response.statusText}`);
      const svgData = await response.text();
      const modifiedSvg = modifySvg(svgData);
      container.innerHTML = modifiedSvg;
    } catch (err) {
      console.error("SVG Load Error:", err);
      container.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
        <text x="10" y="50" fill="red">Error loading SVG</text>
      </svg>`;
    }
  }

  async function initExcalidrawSVG() {
    const containers = document.querySelectorAll('.excalidraw-svg');
    for (const container of containers) {
      await loadAndInjectSvg(container);

      // Watch for theme changes on <html>
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.attributeName === 'class') {
            loadAndInjectSvg(container); // Re-render SVG on theme change
          }
        }
      });

      observer.observe(document.documentElement, { attributes: true });
    }
  }

  document.addEventListener('DOMContentLoaded', initExcalidrawSVG);
  document.addEventListener('astro:page-load', initExcalidrawSVG);
</script>

<style>
  :global(.excalidraw-svg svg) {
    width: 100%;
    height: auto;
  }

  /* Light mode */
  :global(html.light .fill-skin-base) {
    fill: rgb(34, 46, 54); /* #222E36 */
  }
  :global(html.light .fill-skin-soft) {
    fill: rgb(40, 39, 40); /* #282728 */
  }
  :global(html.light .stroke-skin-accent) {
    stroke: rgb(26, 26, 26); /* #1A1A1A */
  }

  /* Dark mode */
  :global(html.dark .fill-skin-base) {
    fill: rgb(175, 176, 177); /* #AFB0B1 */
  }
  :global(html.dark .fill-skin-soft) {
    fill: rgb(175, 176, 177); /* #AFB0B1 */
  }
  :global(html.dark .stroke-skin-accent) {
    stroke: rgb(245, 245, 245); /* #F5F5F5 */
  }

  :global(.excalidraw-element) {
    transition: all 0.3s ease-in-out;
  }

  :global(.excalidraw-element:hover) {
    opacity: 0.8;
  }
</style>
